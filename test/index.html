<!doctype html>
<html>
<head>
  <title>EvDa test suite</title>
  <link rel=stylesheet href=qunit.css>
  <script src=jquery.js></script>
  <script src=underscore.js > </script>
  <script src=../src/evda.js > </script>
  <script src=../src/evda-helper.js > </script>
  <script src=qunit.js > </script>
</head>
<body>
  <h1 id=qunit-header>EvDa test suite</h1>
  <h2 id="qunit-banner"></h2>
  <div id="qunit-testrunner-toolbar"></div>
  <h2 id="qunit-userAgent"></h2>
  <ol id="qunit-tests"></ol>
</body>
<script>
$(function(){
  
module("Initialization");
  test("No arguments", function(){
    var ev = EvDa();
    equal(typeof ev, 'function', "Initialized");
  });

  test("K/V pair", function(){
    var ev = EvDa({key: 'value'});
    equal(ev.db.key, 'value', "Initialized");
  });

module("Basic");
  test("Set a key", function(){
    var ev = EvDa();
    ev('key', 'value');
    equal(ev.db.key, 'value', "Initialized");
  });

  test("Set a key, object style", function(){
    expect(1);
    var ev = EvDa();
    ev({key: 'value'});
    equal(ev.db.key, 'value', "Initialized");
  });
  
  test("Set a key, object style with array", function(){
    expect(3);
    var ev = EvDa();
    ev({
      key1: 'value1',
      key2: [1,2,3]
    });

    equal(ev.db.key1, 'value1', "Initialized");
    equal(ev.db.key2.length, 3, "Array set");
    equal(ev.db.key2[1], 2, "values are right");
  });


  test("Set 3 keys, object style", function(){
    expect(6);
    var ev = EvDa();

    ev({key0: function(){
        equal(_.keys(ev.db).length, 3 + 1, '3 Keys exist before first callback is run');
      }
    });

    ev({
      key2: function(){
        equal(ev.db.key1, 1, 'Keys appear to have the correct value');
      },
      key1: function(){
        equal(_.keys(ev.db).length, 3 + 1, 'All 3 callbacks are run');
      }
    });

    ev({
      key0: 'value0',
      key1: 1,
      key2: true
    });

    equal(ev.db.key0, 'value0', "Initialized key0");
    equal(ev.db.key1, 1, "Initialized key1");
    equal(ev.db.key2, true, "Initialized key2");
  });

  test("Get a key", function(){
    var ev = EvDa();
    ev('key', 'value');
    equal(ev('key'), 'value', "Initialized");
  });

  test("Unset a key", function(){
    var ev = EvDa();
    ev('key', 'value');
    equal(ev.db.key, 'value', "Initialized");
    ev.unset('key')
    equal(_.keys(ev.db).join(''), '', "Removed");
  });

module("OO binding");
  test("Set a key", function() {
    expect(3);
    function m() {
      var ev = EvDa.call(this);

      this.callback = function() {
        equal(1, 1, "binding done");
      }

      ev.isset('key', function() {
        equal(this.value, 123, "binding done");
        equal(typeof(self.value), 'undefined', "right scope");
        this.callback();
      });

      this.value = 123;

      ev.set('key');
    }
    new m();
  });

  test("handy setter", function(){
    var ev = EvDa();

    var cb = ev.set('key');
    cb(1);

    equal(ev('key'), 1, 'cb style setter ran');
  });

module('context');
  test('basic context', function(){
    expect(1);

    function Klass() {
      this.events = EvDa(this);
      this.key = 'value';
    }

    var k = new Klass();
    k.events('a', function(m) {
      equal(this.key, 'value', 'this pointer has been passed');
    });

    k.events('a', 'value');

  });

  test('basic context with exposure', function(){
    expect(3);

    function Person(name) {
      this.events = EvDa(this);
      this.name = name;
      this.events.expose('greet');
    }

    equal('expose' in EvDa._ext, true, 'evda has been extended');

    var john = new Person('john');
    john.greet(function(when) {
      equal(this.name, 'john', 'this pointer has been passed');
      equal(when, 'morning', 'the args have been preserved');
    });
      
    john.greet('morning');

  });
module('chaining')
  test('basic chain', function(){
    expect(3);

    var ev = EvDa({key: 1}), ix = 0;
    ev.on('key', function() {
      equal(ix, 0, "this is run first");
      ix++;
    }).after(function(value, meta){
      equal(value, 1, 'this is run from the right context');
      equal(ix, 1, "this is run second");
    });

    ev('key',1);

  });

  test('longer chain', function(){
    expect(4);

    var ev = EvDa({key: 1}), ix = 0;
    ev.on('key', function() {
      equal(ix, 0, "this is run first");
      ix++;
    }).after(function(value, meta){
      equal(value, 1, 'this is run from the right context');
      equal(ix, 1, "this is run second");
      ix++;
    }).after(function(value, meta){
      equal(ix, 2, "this is run third");
    });

    ev('key',1);

  });

  test('deregistered chain', function(){
    expect(2);

    var ev = EvDa({key: 1}), ix = 0;

    var cb = ev.on('key', function() {
      equal(ix, 0, "this is run first");
      ix++;
    }, {meta: 1}).after(function(value, meta){
      equal(false, true, "this is not run");
      ix++;
    }).after(function(value, meta){
      equal(ix, 1, "this is run second");
    });

    // So now there should be a second element
    // in the callback array that we can unregister
    ev.del(cb[1]);

    ev('key',1);
  });

module('fire');
  test("scalar fire", function(){
    expect(1);
    var ev = EvDa({key: 1});

    ev('key', function(key, obj){
      equal(key, 1, "Everything is fine");
    });
    ev.fire('key');
  });

  test("list fire", function(){
    expect(2);
    var ev = EvDa({keyA: 1, keyB: 2});

    ev('keyA', function(key, obj){
      equal(key, 1, "Everything is fine");
    });

    ev('keyB', function(key, obj){
      equal(key, 2, "Everything is fine");
    });

    ev.fire(['keyA', 'keyB']);
  });
  test("scalar fire", function(){
    expect(2);
    var ev = EvDa({key: 1});

    ev('key', function(key, obj){
      equal(key, 1, "Everything is fine");
    });
    ev.fire('key');
    ev.fire('key');
  });
  test("empty fire", function(){
    expect(1);
    var ev = EvDa({key: {}});

    ev('key', function(key, obj){
      equal(JSON.stringify(key), '{}', "Everything is fine");
    });
    ev.fire('key');
  });
  test("empty fire", function(){
    expect(1);
    var ev = EvDa({where: {}});

    ev('where', function(key, obj){
      equal(JSON.stringify(key), '{}', "Everything is fine");
    });
    ev.fire('where');
  });

module("empty");
  test("fill in an object and empty it", function() {
    var ev = EvDa();
    ev('key', 'value');
    ev.empty();
    equal(_.keys(ev.db).length, 0);
  });

  test("fill in an object and empty it, make sure callbacks aren't called", function() {
    expect(0);
    var ev = EvDa();
    ev('key', 'value');
    ev('key', function(){
      equal(true, true, "don't call");
    });
    ev.empty();
  });

  test("fill in an object and empty it, make sure callbacks are registered upon refilling", function() {
    expect(1);
    var ev = EvDa();
    ev('key', 'value');
    ev('key', function(){
      equal(true, true, "do call");
    });
    ev.empty();
    ev('key', 'value');
  });

module("sniff");
  test("register object callbacks, set from object, make sure they all are hit", function(){
    expect(3);
    var ev = EvDa();

    ev.sniff();
    ev({
      b: function(value) { equal(value, 'b', 'object (b) Callback triggered'); },
      a: function(value) { equal(value, 'a', 'object (a) Callback triggered'); },
      c: function(value) { equal(value, 'c', 'object (c) Callback triggered'); },

      // Shouldn't hit
      d: function(value) { equal(value, 'd', 'object (d) Callback triggered'); }
    });

    ev({
      a: 'a',
      b: 'b',
      c: 'c',

      // Has nothing associated with it
      e: 'e'
    });
  });

  test("ignore bubble'd top", function(){
    expect(1);
    var ev = EvDa();

    ev.sniff('');
    var keys = ev.sniff();

    equal(keys.length, 0, 'zero keys ignored');
  });

  test("ignore 2 keys with a single call", function(){
    expect(2);
    var ev = EvDa();

    ev.sniff('a','b');
    var keys = ev.sniff();

    equal(keys.length, 3, 'two keys ignored');
    equal(keys[1], 'a', 'first key is right');
  });

  test("ignore 2 keys with multiple calls", function(){
    expect(2);
    var ev = EvDa();

    ev.sniff();
    ev.sniff('a');
    ev.sniff('b');
    var keys = ev.sniff();

    equal(keys.length, 3, 'two keys ignored');
    equal(keys[1], 'a', 'first key is right');
  });

  test("unignore 2 keys with multiple calls", function(){
    expect(2);
    var ev = EvDa();

    ev.sniff();
    ev.sniff('a');
    ev.sniff('b');

    ev.sniff('a');
    var keys = ev.sniff();

    equal(keys.length, 2, 'two keys ignored');
    equal(keys[1], 'b', 'first key is right');
  });
 
module("Pausing");
  test("pause responding to a callback until a variable is set, then play it", function(){
    expect(2);
    var ev = EvDa(), flag = false;

    ev('key', function(val) {
      equal(flag, true, 'callback successfully paused');
      equal(val, 'value2', 'making sure that the final value is the one we have');
    });

    ev.pause(); 

      ev('key', 'value');
      ev.set('key', 'value1');
      ev({key: 'value2'});
      flag = true;

    ev.play();

  });


  test("Making sure pause can run multiple times without side-effects", function() {
    expect(2);
    var ev = EvDa(), flag = false;

    ev('key', function(val) {
      equal(flag, true, 'callback successfully paused');
      equal(val, 'value1', 'making sure that the final value is the one we have');
    });

    ev.pause(); 
    ev.pause(); 
    ev.pause(); 
    ev.pause(); 

      // permuting the run order to also test that
      ev('key', 'value');
      ev({key: 'value2'});
      ev.set('key', 'value1');
      flag = true;

    ev.play();

  });

  test("Making sure play can run multiple times without side-effects", function() {
    expect(2);
    var ev = EvDa(), flag = false;

    ev('key', function(val) {
      equal(flag, true, 'callback successfully paused');
      equal(val, 'value', 'making sure that the final value is the one we have');
    });

    ev.pause(); 

      // permuting the run order to also test that
      ev.set('key', 'value1');
      ev({key: 'value2'});
      ev('key', 'value');
      flag = true;

    ev.play();
    ev.play();
    ev.play();
    ev.play();

  });

module('Last');
  test('seeing if last value is propagated', function(){
    expect(1);
    var ev = EvDa();
    ev('key', function() {
      return 'abc';
    });
    ev('key', function(obj, meta) {
      equal(meta.last, 'abc', 'propagated');
    });
    ev('key', 'value');
  });
  test('seeing if last value is registered', function(){
    expect(1);
    var ev = EvDa();
    ev('key', function() {
      return 'abc';
    });
    ev('key', function(obj, meta) {
      return 'def';
    });
    ev('key', 'value');
    equal(ev().last.key, 'def', 'last value is registered right')
  });
  test('seeing if last value is registered at after right', function(){
    expect(1);
    var ev = EvDa();
    ev.after('key', function() {
      return 'abc';
    });
    ev('key', function(obj, meta) {
      return 'def';
    });
    ev('key', 'value');
    equal(ev().last.key, 'abc', 'last value is registered right')
  });

module('Bubbling');
  test("grouping events through dot notation", function(){
    expect(1);
    var ev = EvDa();

    ev('group', function(value) {
      equal(value.key, 1, 'Callback triggered')
    });
    ev('group.key', 1);
  });

  test("grouping events through dot notation - multi-set", function(){
    expect(2);
    var ev = EvDa();

    ev('group.key1', 1);

    ev('group', function(value) {
      equal(value.key1, 1, 'Callback triggered')
      equal(value.key2, 2, 'Callback triggered')
    });

    ev('group.key2', 2);
  });

  test("imported list - bubbling check" , function(){
    expect(1);
    var ev = EvDa({key: 'value'});

    equal(ev('').key, 'value', 'correct');
  });

  test("grouping events through dot notation - unset cascading up", function(){
    var ev = EvDa();

    ev('key', 'value');
    equal(ev('').key, 'value', 'correct');
    ev.unset('key');
    equal('key' in ev(''), false, 'key removed');
  });

  test("grouping events through dot notation - unset cascading up", function(){
    var ev = EvDa();

    ev('a.b.c', 'value');
    equal(ev('a.b').c, 'value', 'correct');
    ev.unset('a.b.c');
    equal('c' in ev('a.b'), false, 'key removed');
  });

  test("grouping events through dot notation - all values correct", function(){
    expect(4);
    var ev = EvDa();

    ev.after('group', function(value) {
      equal(value.key1, 1, 'Callback triggered')
      equal(ev('group.key1'), 1, 'correct in function full dot');
      equal(ev('group').key1, 1, 'correct in function single reference');
      equal(ev('').group.key1, 1, 'correct in function double reference');
    });

    ev('group.key1', 1);
  });

  test("grouping events through dot notation - cascaded callback", function(){
    expect(4);
    var ev = EvDa(), order = 0;

    ev('group.key', function(value) {
      equal(value, 1, 'Callback triggered')
      equal(order, 0, 'Ran first');
      order++;
    });

    ev('group', function(value) {
      equal(value.key, 1, 'Callback triggered')
      equal(order, 1, 'Ran second');
    });

    ev('group.key', 1);
  });

  test("grouping events through dot notation - sets", function(){
    expect(4);
    var ev = EvDa();

    ev('a.b', function(value) {
      equal(true, true, 'callback');
    });

    ev('a', function(value) {
      equal(true, true, 'callback');
    });

    ev.setAdd('a.b', 1);
    ev.setAdd('a.b', 2);

  });

  test("grouping events through dot notation - global scope - object fire test", function(){
    expect(2);
    var ev = EvDa();

    ev('', function(value) {
      equal(value.a, 1, 'callback');
      equal(value.b, 2, 'callback');
    });

    // this should only be run once.
    ev({
      a: 1,
      b: 2
    });
  });

  test("grouping events through dot notation - global scope", function(){
    expect(1);
    var ev = EvDa();

    ev('', function(value) {
      equal(value.a, 1, 'callback');
    });

    ev('a', 1);
  });

  test("grouping events through dot notation - sets - unique list", function(){
    expect(4);
    var ev = EvDa();

    ev('a.b', function(value) {
      equal(true, true, 'callback');
    });

    ev('a', function(value) {
      equal(true, true, 'callback');
    });

    ev.setAdd('a.b', 1);
    ev.setAdd('a.b', 2);

    // this shouldn't be run since
    // the value is already in the set.
    ev.setAdd('a.b', 1);
  });
  
  test("downward referencing", function(){
    expect(3);
    var ev = EvDa();

    ev('key', {value: 123});

    equal(ev('').key.value, 123);
    equal(ev('key').value, 123);
    equal(ev('key.value'), 123);
  });

  test("downward referencing - multi-level", function(){
    expect(4);
    var ev = EvDa();

    ev('a', {b: {c: 123}});

    equal(ev('').a.b.c, 123);
    equal(ev('a').b.c, 123);
    equal(ev('a.b').c, 123);
    equal(ev('a.b.c'), 123);
  });

  test("invalid downward referencing", function(){
    expect(1);
    var ev = EvDa();

    ev('key', 1);

    equal(ev('key.value'), undefined);
  });

  test("grouping events and downward referencing - multi-level + half-assign", function(){
    expect(5);
    var ev = EvDa();

    ev('a.b', {c: {d: 123}});

    equal(ev('').a.b.c.d, 123);
    equal(ev('a').b.c.d, 123);
    equal(ev('a.b').c.d, 123);
    equal(ev('a.b.c').d, 123);
    equal(ev('a.b.c.d'), 123);
  });


  test("grouping events through dot notation - multi-level", function(){
    expect(1);
    var ev = EvDa();

    ev('a', function(value) {
      equal(value.b.c.d, 1, 'Callback triggered')
    });

    ev('a.b.c.d', 1);
  });

  test("grouping events through dot notation - multi-level cascaded", function(){
    expect(6);
    var ev = EvDa(), order = 0;

    ev('a', function(value) {
      equal(value.b.c.d, 1, 'Callback triggered')
      equal(order, 2, 'Ran last');
      order++;
    });

    ev('a.b', function(value) {
      equal(value.c.d, 1, 'Callback triggered')
      equal(order, 1, 'Ran second');
      order++;
    });

    ev('a.b.c', function(value) {
      equal(value.d, 1, 'Callback triggered')
      equal(order, 0, 'Ran first');
      order++;
    });

    ev('a.b.c.d', 1);
  });

  test("grouping events through dot notation - multi-level cascaded with group assign", function(){
    expect(6);
    var ev = EvDa(), order = 0;

    ev({
      'a': function(value) {
        equal(value.b.c.d, 1, 'Callback triggered')
        equal(order, 2, 'Ran last');
        order++;
      },

      'a.b': function(value) {
        equal(value.c.d, 1, 'Callback triggered')
        equal(order, 1, 'Ran second');
        order++;
      },

      'a.b.c': function(value) {
        equal(value.d, 1, 'Callback triggered')
        equal(order, 0, 'Ran first');
        order++;
      }
    });

    ev('a.b.c.d', 1);
  });

  test("grouping events through dot notation - multi-level cascaded with multi-object group assign", function(){
    expect(6);
    var ev = EvDa();

    ev('a.b.e', 2);
    ev('a.f', 3);

    ev({
      'a': function(value) {
        equal(value.b.c.d, 1, 'Callback triggered');
        equal(value.f, 3, 'object is there');
        equal(value.b.e, 2, 'object is there');
      },

      'a.b': function(value) {
        equal(value.c.d, 1, 'Callback triggered');
        equal(value.e, 2, 'object is there');
      },

      'a.b.c': function(value) {
        equal(value.d, 1, 'Callback triggered');
      }
    });

    ev('a.b.c.d', 1);
  });

module("Callbacks on set");
  test("register a callback, arglist style", function(){
    expect(1);
    var ev = EvDa();

    ev('key', function(value) {
      equal(value, 'value', 'Callback triggered');
    });

    ev('key', 'value');
  });

  test("register a callback, object style", function(){
    expect(1);
    var ev = EvDa();

    ev({keyobj: function(value) {
      equal(value, 'value', 'Callback triggered');
    }});

    ev('keyobj', 'value');
  });

  test("register multiple callbacks, make sure they all are hit", function(){
    expect(6);
    var ev = EvDa();

    ev('keyobj', function(value) {
      equal(value, 'value', 'arglist Callback triggered');
    });

    ev({keyobj: function(value) {
      equal(value, 'value', 'object (1) Callback triggered');
    }});

    ev({
      nothere: function(value) {},
      keyobj: function(value) {
        equal(value, 'value', 'object (2) Callback triggered');
      }
    });

    ev('keyobj', 'value');
    ev('keyobj', 'value');
  });

  test("register array callbacks, make sure they all are hit", function(){
    expect(3);
    var ev = EvDa();

    ev(['a', 'b', 'c', 'd'], function(value, meta) {
      equal(meta.key, value, 'object Callback triggered');
    });

    ev({
      a: 'a',
      b: 'b',
      c: 'c',

      // Has nothing associated with it
      e: 'e'
    });
  });

  test("register object callbacks, set from object, make sure they all are hit", function(){
    expect(3);
    var ev = EvDa();

    ev({
      b: function(value) { equal(value, 'b', 'object (b) Callback triggered'); },
      a: function(value) { equal(value, 'a', 'object (a) Callback triggered'); },
      c: function(value) { equal(value, 'c', 'object (c) Callback triggered'); },

      // Shouldn't hit
      d: function(value) { equal(value, 'd', 'object (d) Callback triggered'); }
    });

    ev({
      a: 'a',
      b: 'b',
      c: 'c',

      // Has nothing associated with it
      e: 'e'
    });
  });

  test("register a callback, expect meta information", function(){
    var ev = EvDa();

    ev('key', function(value, meta) {
      equal(_.keys(meta).sort().join(' '), 'done key meta old result value', 'Meta information there');
      equal(meta.old, undefined, 'Old value correct');
      equal(meta.key, 'key', 'key correct');
    });

    ev('key', 'value');
  });

  test("register a callback, pass meta information", function(){
    expect(1);
    var ev = EvDa();

    ev('key', function(value, meta) {
      equal(meta.meta, 'meta', 'meta info correct');
    });

    ev('key', 'value', 'meta');
  });

  test("register a callback, pass meta object information after a test", function(){
    expect(2);
    var ev = EvDa();

    ev.test('key', function(){
      return true;
    });

    ev('key', function(value, meta) {
      equal(meta.meta.one, true, 'meta info correct');
    });
    ev('key', function(value, meta) {
      equal(meta.meta.one, true, 'meta info correct');
    });

    ev('key', 'value', {one: true});
  });

  test("register a callback, pass meta object information", function(){
    expect(1);
    var ev = EvDa();

    ev('key', function(value, meta) {
      equal(meta.meta.key, 'value', 'meta info correct');
    });

    ev('key', 'value', {key: 'value'});
  });

  test("register a callback, pass meta as middleware", function(){
    expect(1);
    var ev = EvDa();

    ev('key', function(value, meta) {
      meta.something = 1;
    });
    ev('key', function(value, meta) {
      equal(meta.something, 1, 'values passed down');
    });

    ev('key', 'value');
  });

module("when");
  test("run if something is set (literal)", function(){
    expect(1);
    var ev = EvDa();

    ev.when("key", "value", function(value) {
      equal(value, 'value', 'Callback triggered');
    });
    ev.when("key", "!value", function(value) {
      equal(value, 'value', 'bad Callback triggered');
    });
    ev('key','value');
  });

  test("run if something is set function", function(){
    expect(1);
    var ev = EvDa();

    ev.when("key", " > 2", function(value) {
      equal(value, 3, 'Callback triggered');
    });
    ev('key', 0);
    ev('key', 1);
    ev('key', 3);
  });

  test("run if an object is set", function(){
    expect(1);
    var ev = EvDa();

    ev.when({
      key1: 'value1',
      key2: 'value2'
    }, function(what){
      equal(true,true, "ran");
    });

    ev('key1', 'value1');
    ev('key2', 'value2');

  });

  test("run if an object is set - false case", function(){
    expect(0);
    var ev = EvDa();

    ev.when({
      key1: 'value1',
      key2: 'value2'
    }, function(what){
      equal(true,true, "ran");
    });

    ev('key1', 'value1');
    ev('key2', 'invalid');

  });

  test("run if an object is set - eventual case", function(){
    expect(1);
    var ev = EvDa();

    ev.when({
      key1: 'value1',
      key2: 'value2'
    }, function(what){
      equal(true,true, "ran");
    });

    ev('key1', 'value1');
    ev('key2', 'invalid');
    ev('key2', 'value2');
  });

  test("run if an object is set - object case", function(){
    expect(1);
    var ev = EvDa();

    ev.when({
      key1: 'value1',
      key2: 'value2'
    }, function(what){
      equal(true,true, "ran");
    });

    ev({
      key1: 'value1',
      key2: 'value2'
    });
  });

  test("run if an object is set - twice case", function(){
    expect(2);
    var ev = EvDa();

    ev.when({
      key1: 'value1',
      key2: 'value2'
    }, function(what){
      equal(true,true, "ran");
    });

    ev('key1', 'value1');
    ev('key2', 'value2');
    ev('key2', 'value2');
  });

  test("run if an object is set - twice case valid state but once called", function(){
    expect(1);
    var ev = EvDa();

    ev.once(ev.when({
      key1: 'value1',
      key2: 'value2'
    }, function(what){
      equal(true,true, "ran");
    }));

    // this is a valid state
    ev('key1', 'value1');
    ev('key2', 'value2');

    // this is a valid state.
    ev('key1', 'value1');
    ev('key2', 'value2');
  });

  test("run if an object is set - type checking false case", function(){
    expect(0);
    var ev = EvDa();

    ev.when({
      key1: true,
      key2: 'value2'
    }, function(what){
      equal(true,true, "ran");
    });

    // this is an invalid state
    ev('key1', {a: 1});
    ev('key2', 'value2');

    // this is too
    ev('key1', 1);
  });

  test("2 arg run if an object is set - type checking true case", function(){
    expect(1);
    var ev = EvDa();

    ev.when('key', function(what){
      equal(true,true, "ran");
    });

    // this is a valid state
    ev('key', true);
    ev('key', false);
  });

  test("run if an object is set - type checking true case", function(){
    expect(1);
    var ev = EvDa();

    ev.when({
      key1: true,
      key2: false,
    }, function(what){
      equal(true,true, "ran");
    });

    // this is a valid state
    ev('key1', true);
    ev('key2', false);

    // this is not
    ev('key2', '');

    // this also is not
    ev('key2', 0);
  });

  test("run if an object is set - twice case invalid state", function(){
    expect(1);
    var ev = EvDa();

    ev.when({
      key1: 'value1',
      key2: 'value2'
    }, function(what){
      equal(true,true, "ran");
    });

    // this is a valid state
    ev('key1', 'value1');
    ev('key2', 'value2');

    // this is an invalid state.
    ev('key1', 'nono');
    ev('key2', 'value2');
  });

  test("run if something is set (array)", function(){
    expect(1);
    var ev = EvDa();

    ev.when("key", [1,2,3], function(value) {
      equal(value.join(''), "123", 'Callback triggered');
    });

    ev.when("key", "value", function(value) {
      equal(value, 'value', 'bad Callback triggered');
    });
    ev('key',[1,2,3]);
  });

  test("run if something is set (functional)", function(){
    expect(1);
    var ev = EvDa();

    ev.when("key", function(test) { return test === "value" }, function(value) {
      equal(value, "value", 'Callback triggered');
    });

    ev.when("key", "!value", function(value) {
      equal(value, 'value', 'bad Callback triggered');
    });
    ev('key',"value");
  });

module("Deletion of callbacks");
  test("register a callback, delete & set twice", function(){
    expect(1);
    var ev = EvDa(), cb;

    cb = ev('key', function(value) {
      equal(value, 'value1', 'Callback triggered');
    });

    ev('key', 'value1');
    ev.del(cb);
    ev('key', 'value3');
  });

  test("register a callback, inline delete & set twice", function(){
    expect(1);
    var ev = EvDa(), cb;

    cb = ev('key', function(value) {
      ev.del(arguments.callee);
      equal(value, 'value1', 'Callback triggered');
    });

    ev('key', 'value1');
    ev('key', 'value3');
  });


module("Onetime callbacks on set");
  test("register a one time callback, set twice", function(){
    expect(1);
    var ev = EvDa();

    ev.once('key', function(value) {
      equal(value, 'value1', 'Callback triggered');
    });

    ev('key', 'value1');
    ev('key', 'value3');
  });

  test("register a one time callback after initial set, set thrice twice", function(){
    expect(2);
    var ev = EvDa();

    var handle = ev('key', function(value) {
      equal(value, 'value1', 'Callback triggered');
    });

    ev('key', 'value1');
    ev.once(handle);
    ev('key', 'value1');
    ev('key', 'value3');
  });

  test("register a one time callback in the middle of many, make sure they are all called", function(){
    var ev = EvDa(), index = 0;

    for(var i = 0; i < 3; i++) {
      with({
        internal: i
      }) {
        
        ev.on('key', function() {
          equal(index, internal, "Called correctly");
          index++;
        });
      }
    }

    ev.once('key', function(value) {
      equal(value, 'value', 'one time call');
    });

    for(; i < 5; i++) {
      with({
        internal: i
      }) {
        
        ev.on('key', function() {
          equal(index, internal, "Called correctly");
          index++;
        });
      }
    }

    index = 0;
    ev('key', 'value');

    index = 0;
    ev('key', 'value');
  });

module("Tests");
  test("Set a key to a value, register a test, deny the set, and check the keys value", function() {
    var ev = EvDa();

    equal(ev.incr("key"), 1, "Key initialized to 1");
    ev.test("key", function(value, meta) {
      equal(value, 2, "Key is attempting to be set to 2");

      // deny it the pleasure.
      var res = meta.done(false);
      equal(res, false, 'Pass through value worked');
    });

    equal(ev.incr("key"), 1, "Key never incremented");
    equal(ev.get("key"), 1, "Key never incremented");

  });

  test("Set a value to a key, wait a bit before going to the next", function(){
    var ev = EvDa(), now = +new Date();

    ev.test('key', function(v, meta) {
      setTimeout(function(){
        meta(true);
      }, 500);
    });

    ev.test('key', function(){ 
      var toTest = +new Date();
      equal(toTest - now > 400, true, "test was delayed");
    });

    ev('key', 1);
  });

  test("Set a value to a key, register a test, change the value in the test", function(){
    var ev = EvDa();

    ev.test('key', function(v, meta) {
      meta.value = 2;
      meta(true);
    });

    ev('key', 1);
    equal(ev.get("key"), 2, "Key set to 2 in the test");
  });

  test("Setadd testing of the value", function() {
    expect(2);
    var ev = EvDa();

    ev.setAdd('key', 1);

    ev.test('key', function(value, meta) {
      equal(meta.set.join(''), 12, 'individual value is correct');
      meta();
    });

    ev('key', function(value) {
      equal(value.join(''), '12', "proper value passed");
    });
    
    ev.setAdd('key', 2);
  });

  test("Setadd testing of the value", function() {
    expect(2);
    var ev = EvDa();

    ev.setAdd('key', 1);
    ev.test('key', function(value, meta) {
      equal(value, 2, 'individual value is correct');
      meta(true);
    });
    ev('key', function(value) {
      equal(value.join(''), '12', "proper value passed");
    });
    
    ev.setAdd('key', 2);
  });

  test("Setadd mutable value", function() {
    expect(2);
    var ev = EvDa();

    ev.setAdd('key', 1);
    ev.test('key', function(value, meta) {
      equal(value, 2, 'individual value is correct');
      meta.value = 3;
      meta(true);
    });
    ev('key', function(value) {
      equal(value.join(''), '13', "proper value passed");
    });
    
    ev.setAdd('key', 2);
  });

  test("Set a key to a value, register a test, deny the set, and check the keys value", function() {
    var ev = EvDa();

    equal(ev.incr("key"), 1, "Key initialized to 1");
    ev.test("key", function(value, meta) {
      equal(value, 2, "Key is attempting to be set to 2");

      // deny it the pleasure.
      var res = meta(false);
      equal(res, false, 'Pass through value worked');
    });

    equal(ev.incr("key"), 1, "Key never incremented");
    equal(ev.incr("key"), 1, "Key never incremented");
    equal(ev.get("key"), 1, "Key never incremented");

  });

module("Or");
  test("Set a key to a value, register a test, deny the set, and try to run an or handler", function() {
    expect(3);
    var ev = EvDa();

    equal(ev.incr("key"), 1, "Key initialized to 1");
    ev.test("key", function(value, meta) {
      equal(value, 2, "Key is attempting to be set to 2");

      // deny it the pleasure.
      meta(false);
    });

    ev.or('key', function(){
      equal(true, true, "function ran");
    });

    ev.incr('key');

  });

module("Callbacks after set");
  test("Register two callbacks, check their execution order", function(){
    expect(2);

    var 
      ev = EvDa(),
      order = 0;

    ev.on('key', function(value) {
      equal(order, 0, 'Order correct');
      order++;
    });

    ev.after('key', function(value) {
      equal(order, 1, 'Order correct');
    });

    ev('key', 'value');
  });

module("Test callbacks on set");
  test("Register an on handler, stop it from happening with a test", function(){
    expect(1);
    var ev = EvDa();

    ev.test('key', function(value, meta) {
      equal(value, 'value', 'Inside the tester');
      meta.done(false);
    });

    ev.on('key', function() {
      equal(true, false, 'This should never be hit');
    });

    ev('key', 'value');
  });

  test("Register an on handler, let it happen with a test", function(){
    expect(2);
    var ev = EvDa();

    ev.test('key', function(value, meta) {
      equal(value, 'value', 'Inside the tester');
      meta.done(true);
    });

    ev.on('key', function(value) {
      equal(value, 'value', 'This should be hit');
    });

    ev('key', 'value');
  });

  test("Register an on handler, have 3 tests with the middle one failing", function(){
    expect(5);
    var ev = EvDa();

    ev.test('key', function(value, meta) {
      equal(value, 'value', 'Inside the tester');
      var res = meta.done(true);
      equal(res, true, 'Pass through value worked');
    });
    ev.test('key', function(value, meta) {
      equal(value, 'value', 'Inside the tester');
      meta.done(false);
    });
    ev.test('key', function(value, meta) {
      equal(value, 'value', 'Inside the tester');
      var res = meta.done(true);
      equal(res, true, 'Pass through value worked');
    });

    ev.on('key', function(value) {
      equal(true, false, 'This should never be hit');
    });

    ev('key', 'value');
  });

  test("Register an on handler, have 3 tests with all passing", function(){
    expect(4);
    var ev = EvDa();

    ev.test('key', function(value, meta) {
      equal(value, 'value', 'Inside the tester');
      meta.done(true);
    });
    ev.test('key', function(value, meta) {
      equal(value, 'value', 'Inside the tester');
      meta.done(true);
    });
    ev.test('key', function(value, meta) {
      equal(value, 'value', 'Inside the tester');
      meta.done(true);
    });

    ev.on('key', function(value) {
      equal(value, 'value', 'This should be hit');
    });

    ev('key', 'value');
  });

module("Adding elements to a set");
  test("Add one element to an undefined set", function(){
    expect(1);
    var ev = EvDa();

    ev.setAdd('s', 1);
    equal(JSON.stringify(ev('s')), '[1]', 'Set exists');
  });

/*
  test("add a key to a set in a play/pause scenario", function() {
    var ev = EvDa();
    ev.pause();
    ev.setAdd('s', 1);
    ev.setAdd('s', 2);
    ev.setAdd('s', 3);
    ev.play();
    equal(JSON.stringify(ev('s').sort()), '[1,2,3]', 'Set exists');
  });
  */

  test("add a key to a set in an array invocation", function() {
    var ev = EvDa();
    ev.setAdd('s', [1, 2, 3]);
    equal(JSON.stringify(ev('s').sort()), '[1,2,3]', 'Set exists');
  });

  test("Add three unique elements to an undefined set", function(){
    expect(1);
    var ev = EvDa();

    ev.setAdd('s', 1);
    ev.setAdd('s', 2);
    ev.setAdd('s', 3);
    equal(JSON.stringify(ev('s').sort()), '[1,2,3]', 'Set exists');
  });

  test("Add three elements (2 unique) to an undefined set", function(){
    expect(1);
    var ev = EvDa();

    ev.setAdd('s', 1);
    ev.setAdd('s', 2);
    ev.setAdd('s', 1);
    equal(JSON.stringify(ev('s').sort()), '[1,2]', 'Set is correct');
  });

module("Removing elements from a set");
  test("Remove an element from an undefined set", function(){
    // This should simply not crash
    var ev = EvDa();

    ev.setDel('s', 1);
  });

  test("Add 3 unique elements and toggling 1 from an undefined set", function(){
    expect(1);
    // This should simply not crash
    var ev = EvDa();

    ev.setAdd('s', 1);
    ev.setAdd('s', 2);
    ev.setAdd('s', 3);

    ev.setToggle('s', 2);

    equal(JSON.stringify(ev('s').sort()), '[1,3]', 'Set is correct');
  });

  test("Add 3 unique elements, one of them twice and remove 1 from an undefined set", function(){
    expect(1);
    // This should simply not crash
    var ev = EvDa();

    ev.setAdd('s', 1);
    ev.setAdd('s', 2);
    ev.setAdd('s', 2);
    ev.setAdd('s', 3);

    ev.setDel('s', 2);

    equal(JSON.stringify(ev('s').sort()), '[1,3]', 'Set is correct');
  });
  test("Add 3 unique elements and remove 1 from an undefined set", function(){
    expect(1);
    // This should simply not crash
    var ev = EvDa();

    ev.setAdd('s', 1);
    ev.setAdd('s', 2);
    ev.setAdd('s', 3);

    ev.setDel('s', 2);

    equal(JSON.stringify(ev('s').sort()), '[1,3]', 'Set is correct');
  });

module("Running a setter");
  test("Setting a variable, checking to see if it's been set", function(){
    expect(2);
    var ev = EvDa();

    ev.set('key', 'value');
    ev.isset('key', function(value) {
      equal(value, 'value', 'Key set to value');
    });
    ev.whenSet('key', function(value) {
      equal(value, 'value', 'Key set to value');
    });
  });
  test("Registering a setter arglist style, then Setting a variable", function(){
    expect(1);
    var ev = EvDa();

    ev.isset('key', function(value) {
      equal(value, 'value', 'Key set to value');
    });
    ev.set('key', 'value');
  });
  test("Array style isset", function(){
    expect(1);
    var ev = EvDa();

    ev.isset(['k','j','l'], function(){
      equal(1, 1, "done");
    });

    ev('k', 1);
    ev('j', 2);
    ev('l', 3);
  });
  test("Array style isset false positive test", function(){
    expect(0);
    var ev = EvDa();

    ev.isset(['k','j','l'], function(){
      equal(1, 0, "should never be here");
    });

    ev('k', 1);
    ev('j', 2);
  });
  test("Array style isset meta test", function(){
    expect(2);
    var ev = EvDa();

    ev.isset(['k','j'], function(arg, meta){
      equal(ev('k'), 1, "should have k == 1");
      equal(ev('j'), 2, "should have j == 2");
    });

    ev('k', 1);
    ev('j', 2);
  });

  test("Registering a setter kv style, then Setting a variable", function(){
    expect(1);
    var ev = EvDa();

    ev.isset({
      key: function(value) {
        equal(value, 'value', 'Key set to value');
      }
    });
    ev.set('key', 'value');
  });

  test("Registering three setters kv style, then Setting a variable", function(){
    expect(3);
    var ev = EvDa();

    ev.isset({
      key0: function(value) {
        equal(value, 'value0', 'Key set to value');
      },
      key1: function(value) {
        equal(value, 'value1', 'Key set to value');
      },
      key2: function(value) {
        equal(value, 'value2', 'Key set to value');
      }
    });

    for(var i = 0; i < 3; i++) {
      ev.set('key' + i, 'value' + i);
    }
  });

module("Tracing");
  test("Tracing function execution", function() {
    expect(2);

    var ev = EvDa(), run = 0; 
    ev().trace.push(function(args) {
      if(run === 0) {
        equal(args[0], 'key', 'Trace called, args correct');
      } else {
        equal(args[0], '', 'Trace called, args correct');
      }
      run++;
    });

    ev('key', 'value');
  });


module("Defining a setter");
  test("Defining a setter arglist style, then probing it with isset", function(){
    expect(2);
    var ev = EvDa(), order = 1;

    ev.setter('key', function() {
      equal(order, 2, 'Order correct - setter run');
      ev('key', 'value');
    });

    equal(order, 1, 'Order correct - setter not run yet');
    order++;
    ev.isset('key');
  });

  test("Defining a setter arglist style asynchronously, then probing it with isset", function(){
    var ev = EvDa(), key = Math.random();

    ev.setter('key', function(done) {
      setTimeout(function(){
        done(key);
      }, 10);
    });

    ev.isset('key', function(value) {
      equal(value, key, 'Asynchronously right. Woohoo');
    });
  });

  test("Defining a setter, then setting a key manually thus negating its use", function(){
    expect(1);
    var ev = EvDa(), order = 1;

    ev.setter('key', function() {
      equal(order, 1, "setter shouldn't have been run");
      ev('key', "value");
    });

    // manually set it.
    ev('key', 'value');

    ev.isset('key', function(value) {
      equal(value, "value", "This should be run");
    });
  });

  test("Defining a setter, in a different order, then setting a key manually thus negating its use", function(){
    expect(1);
    var ev = EvDa(), order = 1;

    // manually set it.
    ev('key', 'value');

    ev.setter('key', function() {
      equal(order, 1, "setter shouldn't have been run");
      ev('key', "value");
    });

    ev.isset('key', function(value) {
      equal(value, "value", "This should be run");
    });
  });

  test("Defining a setter after a probing with isset", function(){
    expect(2);
    var ev = EvDa(), order = 1;

    ev.isset('key', function() {
      equal(order, 2, 'Order correct');
    });

    ev.setter('key', function() {
      equal(order, 1, 'Order correct');
      order++;
      ev('key', 'value');
    });

  });

});
module("Miscellaneous");

  test("Reordering of setters", function(){
    expect(2);
    var ev = EvDa(), counter = 0;

    ev('key', function(){
      equal(counter, 1, 'Order correct');
      counter++;
    });

    ev('key', function(){
      equal(counter, 0, 'Order correct');
      counter++;
    });

    var Setters = ev.on('key');

    // reorder things
    Setters.push(Setters.shift());

    // set the key
    ev('key','value');
  });

  test("Mass assign of setters", function(){
    expect(2);
    var ev = EvDa(), counter = 0;

    ev('key', [
        function(){
          equal(counter, 0, 'Order correct');
          counter++;
        },
        function(){
          equal(counter, 1, 'Order correct');
          counter++;
        }
      ]
    );


    // set the key
    ev('key','value');
  });

  test("Mass cross-assign of setters", function(){
    expect(2);
    var ev = EvDa(), counter = 0;

    ev('key-notset', [
        function(){
          equal(counter, 0, 'Order correct');
          counter++;
        },
        function(){
          equal(counter, 1, 'Order correct');
          counter++;
        }
      ]
    );

    ev.on('key', ev.on('key-notset'));

    // set the key
    ev('key','value');
  })
</script>


